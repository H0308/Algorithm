//
// Created by 18483 on 2025/2/19.
//
#include <iostream>

using namespace std;

// 力扣70.爬楼梯
/*
 * 本题的难点就是找出递推公式，可以观察规律：
 * 因为一次只能走1步或者2步，所以如果n分别等于如下值时，分别有对应的几种情况：
 * 1：1种，直接走一步
 * 2：2种，1+1，2
 * 3：3种，1+1+1，1+2，2+1，其中1+1+1中的1+1和2+1中的2来自于第二种情况，1+2中的1来自于第一种情况
 * 4：5种，1+1+1+1+1，1+2+1，2+1+1，1+1+2，2+2，其中1+1+1+1中的1+1+1、1+2+1中的1+2、2+1+1中的2+1来自第三种情况，1+1+2中的1+1、2+2中的第一个2来自于第二种情况
 * 以此类推，可以发现，当前阶数需要的方法个数是前两个阶数需要的方法个数总和
 * 所以，根据动规五部曲：
 * 1. dp数组元素和下标的含义：在本题中，下标为0的元素没有含义，其余的下标表示当前阶数，每个元素即为到当前阶数的方法数
 * 2. 递推公式：dp[i] = dp[i - 1] + dp[i - 2]
 * 3. 初始化：因为下标0没有含义，但是建议初始化为0，更符合直觉，因为需要利用到前两个阶数的方法，所以先初始化dp[1]=1，dp[2]=2
 * 4. 遍历顺序：因为计算当前结果要利用到上两次计算的结果，所以采用正向遍历
 * 5. 验证dp数组是否满足要求
 * 本题直接用滚动数组进行空间优化
 */
class Solution70
{
public:
    int climbStairs(int n)
    {
        if (n == 1)
            return 1;
        else if (n == 2)
            return 2;

        int cur = 0;
        int prev = 2;
        int prevP = 1;

        for (int i = 3; i <= n; i++)
        {
            cur = prev + prevP;
            prevP = prev;
            prev = cur;
        }

        return cur;
    }
};
