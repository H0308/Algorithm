//
// Created by 18483 on 2025/1/31.
//

#include <iostream>
#include <vector>

using namespace std;

// 力扣376.摆动序列
/*
 * 解决本题之前先要理解本题的意思，本题中所谓的摆动序列，实际上就是确定当前值为局部峰值：
 * 1. 当前值-左侧值大于或者小于0
 * 2. 右侧值-当前值小于或者大于0
 * 满足上面两个条件就说明当前数值在左右两个数值之间属于峰值
 * 根据这个特点，可以考虑下面的情况：
 * 1. 持续递增/递减无平坡
 * 2. 递增/递减存在平坡
 * 3. 只有两个彼此不同的元素
 * 4. 从某点平坡再持续递增
 *
 * 首先考虑第一种情况，以[1,17,5,10,13,15,10,5,16,8]为例
 * 在第一个5变化到10之后，10的后面是13，此时的5开始就是持续递增无平坡的情况，直到遇到15，而以为10的左右两侧只有左侧满足递增，所以需要考虑“删除元素”，直到15为止
 * 当抵达15元素时，再遇到第二个10时，又出现了持续递减无平坡的情况，同样，去除10直到5
 * 对于第二种情况，以[1,2,2,2,1]为例
 * 当1进入第一个2时，此时的2左侧存在递增，但是右侧并不是递增，所以并没有满足局部峰值的条件，需要“删除元素”，直到最后一个2元素
 * 对于第三种情况，以[1,2]为例
 * 当1进入2时，左侧存在一个递增，但是右侧已经没有了数据，根据题目要求：仅有一个元素或者含两个不等元素的序列也视作摆动序列，所以可以考虑直接写死，也可以考虑默认给定一个序列值为1，并在该基础上改变
 * 对于第四种情况，以[1,2,2,2,3,4]为例
 * 可以看到从1到第一个2存在坡度，但是后面先平坡再递增，此时就需要注意更新第一个坡度的时机，因为平坡过程中，第一个坡度值一直为0直到遇到最后一个2时，两次的坡度改变，变为第二种情况
 * 但是，此时并不应该修改第一个坡度值，因为第二次的坡度改变依旧是递增趋势
 *
 * 根据上面4种情况，可以分析出下面的逻辑：
 * 1. 首先确定结果变量，初始化为1，表示默认存在一个坡度
 * 2. 接着通过两个变量prediff和curdiff记录前一个坡度和后一个坡度
 * 3. 根据条件prediff<0 && curdiff>0或者prediff > 0 && curdiff < 0（处理第一种情况）或者prediff == 0 && curdiff < 0或者prediff == 0 && curdiff > 0（第二种情况）
 * 4. 先计算curdiff=nums[i + 1] - nums[i]，为了防止prediff因为第4种情况时更新成了0，考虑在判断条件成立时更新prediff=curdiff
 */
class Solution376
{
public:
    int wiggleMaxLength(vector<int> &nums)
    {
        // 默认存在一个子序列长度
        int count = 1;
        int prediff = 0;
        int curdiff = 0;

        // 假设右侧存在一个峰值，即默认结果1
        for (int i = 0; i < nums.size() - 1; i++)
        {
            curdiff = nums[i + 1] - nums[i];
            if ((prediff >= 0 && curdiff < 0) || (prediff <= 0 && curdiff > 0))
            {
                prediff = curdiff;
                count++;
            }
        }

        return count;
    }
};
