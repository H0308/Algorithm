//
// Created by 18483 on 2025/2/6.
//
#include <iostream>
#include <vector>

using namespace std;

// 力扣45.跳跃游戏Ⅱ
/*
 * 本题的基本思路是找出最大可以覆盖的范围从而减少跳跃的次数，分为两种情况：
 * 1. 当前位置+当前位置的步数可以覆盖到结尾
 * 2. 当前位置+当前位置的步数不可以覆盖到结尾
 * 先记录一下当前位置+当前位置的步数，如果该值大于下一次要走的步数，就更新该值
 * 接着判断当前位置是否已经到当前步数的终点位置，此时分为两种情况：
 * 1. 已经到当前步数的终点位置
 * 2. 没有到当前步数的重点位置
 * 对于第一种情况也分为两种情况：
 * 1. 当前位置并不是最后一个元素的位置
 * 2. 当前位置已经是最后一个元素的位置
 * 对于此时的第一种情况来说就需要更新到下一次的步数，因为贪的是最大的覆盖范围，所以更新到下一次最大可以走的步数值，并更新跳跃次数
 */
class Solution45
{
public:
    int jump(vector<int> &nums)
    {
        int cur = 0;
        int next = 0;
        int count = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            // 记录下一次最大可以抵达的位置
            next = max(i + nums[i], next);
            // 如果i等于最大可以抵达的位置时存在两种情况
            // 1. 还没有走到终点，需要更新下一次最大可以抵达的位置
            // 2. 走到了终点，直接退出
            if (i == cur)
            {
                if (cur != nums.size() - 1)
                {
                    cur = next;
                    count++;
                }
                else
                    break; // 已经走到终点，直接退出
            }
        }

        return count;
    }
};
