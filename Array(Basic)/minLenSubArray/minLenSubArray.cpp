//
// Created by 18483 on 2024/10/22.
//
#include <iostream>
#include <vector>
#include <unordered_map>
// #include <bits/stdc++.h>
// 力扣209.长度最小的子数组
// 暴力解法，见网站
/*
 * 暴力解法基本思路：
 * 外层循环固定为起始位置，内层循环固定为终止位置
 * 通过内层循环的不断进行一直计算sum以及子数组长度
 * 当sum>=target时就跳出内层循环更新外层循环，内层循环再从外层循环下标位置继续寻找
 * 这里内层循环不要从头开始，否则内层循环和外层循环构成的区间并不是有效区间，例如i=1,j=0，构成的区间为[1,0]
 */
// 双指针――滑动窗口算法
/*
 * 滑动窗口的本质还是双指针，之所以叫滑动窗口本质就是通过终止位置的不断移动，
 * 满足条件时不断更新起始位置直到条件重新不成立，再继续更新终止位置
 * 对于本题而言，暴力解法中的循环主要以起始位置为主，所以导致循环复杂度增加
 */
class Solution209
{
public:
    int minSubArrayLen(int target, std::vector<int> &nums)
    {
        int start = 0;
        int len = INT_MAX; // 定义为最大值可以确保比较时一定可以取到最小值
        int sum = 0;
        for (int end = 0; end < nums.size(); end++)
        {
            // 通过end移动计算起始位置和终止位置区间的和sum
            sum += nums[end];
            // 如果sum大于等于target，说明已经找到符合条件的子数组，可以更新sum和start，准备下一次寻找子数组
            // 此处需要循环判断sum是否在start更新时依旧满足sum>=target，不满足时再更新end继续计算和
            // 否则就相当于移出窗口
            while (sum >= target)
            {
                // 先计算当前满足条件时的下标
                len = std::min(len, end - start + 1);
                // 更新start和sum
                sum -= nums[start];
                start++;
            }
        }

        // 如果不存在指定的子数组，则返回0
        if (len == INT_MAX)
        {
            return 0;
        }

        return len;
    }
};

// 力扣904.水果成篮
/*
 * 根据题目的描述，可以联想出本题涉及到一个窗口的进入和更新
 * 窗口进入：当前元素不存在时，插入到当前容器
 * 窗口更新：当元素个数超过两个时，考虑更新窗口直到重新满足条件
 * 本题并没有提到每一个元素只出现一次，但是需要确保容器中只有两个元素，所以需要用到可以去重的容器
 * 可以选择的结构：红黑树，容器对应的就是set和map，也可以考虑使用unordered_map或者unordered_set
 * 但是在更新窗口时，如果直接删除容器中的元素可能会因为每一个元素不止出现一次导致提前更新窗口
 * 例如[3,3,3,1,2,1,1,2,3,3,4]，如果直接使用一个红黑树容器，在插入时3,1,2，此时size为3需要更新窗口
 * 进入循环更新逻辑时，因为没有对元素进行计数，导致set直接删除start指向的第一个3，现在size重新回到2，循环提前结束
 * 所以可以考虑使用map或者unordered_map，如果元素不存在直接插入，否则只更新计数器
 * 最后，更新计数器不可以在更新窗口中更新，因为不能确定一定会出现3种水果
 */
class Solution904
{
public:
    int totalFruit(std::vector<int> &fruits)
    {
        int start = 0;
        int len = 0;
        std::unordered_map<int, int> m; // 使用unordered_map，查找的时间复杂度为O(1)
        for (int end = 0; end < fruits.size(); end++)
        {
            // 确定元素是否存在，不存在就添加
            m[fruits[end]]++;
            // 当不满足条件：两个篮子中的水果种类大于2种时调整窗口
            while (m.size() > 2)
            {
                // 直到指定元素的计数器为0时才删除，否则一直减少计数器
                if ((--(m.find(fruits[start])->second)) == 0)
                {
                    m.erase(fruits[start]);
                }
                // 更新窗口
                start++;
            }

            // 更新长度
            len = std::max(len, end - start + 1);
        }

        return len;
    }
};

// 力扣76.最小覆盖子串
/*
 * 本题暴力思路：枚举出所有包含查找子串的所有字符的字符串，比较长度取出最小的子串
 * 本题可以考虑使用滑动窗口的方法
 * 为什么：根据暴力解法，每一次枚举所有包含的子串这个过程中涉及到一些重复的步骤，例如已经完全包含内容的子串被多次枚举
 * 而如果需要将这个过程中的枚举次数减少，策略就是找到最接近最优解的一个子串，整个遍历过程中，当一个指针在遍历s字符串时
 * 这个指针离起始位置的距离越来越远，此时与起始位置的指针就构成一个区间，而当刚好满足找到子串的条件时，就需要减小区间
 * 确保能找到更小一点的区间，而这个过程就正好满足不定长滑动窗口的过程
 * 怎么用：
 * 1. 题目提到了t字符串中的重复字符也需要完全匹配，所以需要使用哈希表来统计出现的次数
 * 2. 构建窗口：在t字符串的哈希表m中找s字符串中的字符，如果出现添加到另一个哈希表c中进行计数，方便更新窗口时比较
 * 3. 更新窗口：当哈希表m中字符的个数与c中对应的字符个数相同，说明一定存在子串包含t中的所有字符，此时就需要更新窗口
 *             否则一定不需要更新窗口。更新窗口的过程中需要记录当前子串的长度已经起始位置方便最后截取字符串，
 *             更新逻辑：让c中的字符个数与m中的字符个数不匹配，即类似于从c中依次移除出现于t中的字符
 * 4. 本题只需要考虑短的字符串中的字符即可，对于s字符串来说，其他字符是否存在不需要考虑
 *
 */
// 滑动窗口
class Solution76
{
public:
    // 哈希表统计数量――定义为成员，方便checkNum函数调用
    std::unordered_map<char, int> m, c;

    // 判断t字符串中字符的个数是否与存在于c中的字符个数相同
    int checkNum()
    {
        for (auto &ch: m)
        {
            // 如果个数不匹配直接返回false
            if (c[ch.first] < ch.second)
            {
                return false;
            }
        }

        // 循环走完说明个数一致
        return true;
    }

    std::string minWindow(std::string s, std::string t)
    {
        // 定义s字符串的窗口端点
        int l = 0, r = 0;
        int len = INT_MAX;
        int ret = -1;
        // 统计字符串t中的字符和个数
        for (auto &ch: t)
        {
            m[ch]++;
        }

        // 构建滑动窗口
        int sz = s.size();
        while (r < sz)
        {
            // 如果s中的字符存在于t中，就插入并计数――构建窗口
            if (m.find(s[r]) != m.end())
            {
                c[s[r]]++;
            }

            // 更新窗口
            // 何时更新：当找到了足够的字符与t中的字符匹配并且区间有效时
            while (checkNum())
            {
                // 如何更新：进入循环说明一定已经找到了满足条件的子串
                // 先更新长度，最后需要通过变量取出返回的子串
                if (r - l + 1 < len)
                {
                    len = r - l + 1;
                    // 更新用于截取子串的起点
                    ret = l;
                }

                // 缩短窗口，判断是否还有满足条件的更短窗口
                if (m.find(s[l]) != m.end())
                {
                    c[s[l]]--;
                }

                l++;
            }

            r++;
        }

        return ret == -1 ? std::string() : s.substr(ret, len);
    }
};
